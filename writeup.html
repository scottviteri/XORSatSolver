<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>XOR Sat Solving</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="sigplan.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript">
(function() {
  document.write('<link rel="stylesheet" href="katex/katex.min.css" />');
})();(function() {document.write('<scr' + 'ipt type="text/javascript" src="katex/katex.min.js"></scr' + 'ipt>');})();(function(f) {
  // A "simple" onLoad function
  if (window.document.readyState == "complete") {
    f();
  } else if (window.document.addEventListener) {
    window.document.addEventListener("DOMContentLoaded", f, false);
  } else if (window.attachEvent) {
    window.attachEvent("onreadystatechange", function() {
      if (window.document.readyState == "complete") {
        f();
      }
    });
  } else {
    var oldLoad = window.onload;
    if (typeof(oldLoad) == "function") {
      window.onload = function() {
        try {
          oldLoad();
        } finally {
          f();
        }
      };
    } else {
      window.onload = f;
    }
  }
})(function() {
  // This is an ugly way to change the doctype, in case the scribble document
  // did not use (with-html5).
  if (!(document.doctype && document.doctype.publicId == '')) {
    if (console && console.log) {
      console.log("Re-wrote the document to use the HTML5 doctype.\n"
                  + "  Consider using the following declaration:\n"
                  + "      @title[#:style (with-html5 manual-doc-style)]{â€¦}");
    }
    var wholeDoc = '<!doctype HTML>\n' + document.documentElement.outerHTML;
    document.open();
    document.clear();
    document.write(wholeDoc);
  }
  var inlineElements = document.getElementsByClassName("texMathInline");
  for (var i = 0; i < inlineElements.length; i++) {
    var e = inlineElements[i];
    katex.render(e.textContent, e, { displayMode:false, throwOnError:false });
  }
  var displayElements = document.getElementsByClassName("texMathDisplay");
  for (var i = 0; i < displayElements.length; i++) {
    var e = displayElements[i];
    katex.render(e.textContent, e, { displayMode:true, throwOnError:false });
  }
});
</script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">XOR Sat Solving</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Introduction%29" class="tocviewlink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Motivation_and_.Background%29" class="tocviewlink" data-pltdoc="x">Motivation and Background</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Overview_of_.Proposed_.Approach%29" class="tocviewlink" data-pltdoc="x">Overview of Proposed Approach</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.Evaluation_.Methodology%29" class="tocviewlink" data-pltdoc="x">Evaluation Methodology</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="#%28part._.Results%29" class="tocviewlink" data-pltdoc="x">Results</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="#%28part._.Conclusion%29" class="tocviewlink" data-pltdoc="x">Conclusion</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="#%28part._.Acknowledgements%29" class="tocviewlink" data-pltdoc="x">Acknowledgements</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.X.O.R_.Sat_.Solving%29" class="tocsubseclink" data-pltdoc="x">XOR Sat Solving</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Introduction%29" class="tocsubseclink" data-pltdoc="x">Introduction</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Motivation_and_.Background%29" class="tocsubseclink" data-pltdoc="x">Motivation and Background</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Overview_of_.Proposed_.Approach%29" class="tocsubseclink" data-pltdoc="x">Overview of Proposed Approach</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.Evaluation_.Methodology%29" class="tocsubseclink" data-pltdoc="x">Evaluation Methodology</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#%28part._.Results%29" class="tocsubseclink" data-pltdoc="x">Results</a></td></tr><tr><td><span class="tocsublinknumber">5.1<tt>&nbsp;</tt></span><a href="#%28part._.Manually_.Generated%29" class="tocsubseclink" data-pltdoc="x">Manually Generated</a></td></tr><tr><td><span class="tocsublinknumber">5.2<tt>&nbsp;</tt></span><a href="#%28part._.Algorithmically_.Generated%29" class="tocsubseclink" data-pltdoc="x">Algorithmically Generated</a></td></tr><tr><td><span class="tocsublinknumber">6<tt>&nbsp;</tt></span><a href="#%28part._.Conclusion%29" class="tocsubseclink" data-pltdoc="x">Conclusion</a></td></tr><tr><td><span class="tocsublinknumber">7<tt>&nbsp;</tt></span><a href="#%28part._.Acknowledgements%29" class="tocsubseclink" data-pltdoc="x">Acknowledgements</a></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cmain~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;main&gt;</a></span></td></tr></table></div></div><div class="maincolumn"><div class="main"><h2><a name="(part._.X.O.R_.Sat_.Solving)"></a>XOR Sat Solving</h2><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Scott Viteri</p></span></div><p><div class="SIntrapara"></div><div class="SIntrapara"><blockquote class="abstract"><p>Satisfiability solving is useful and important, but surprisingly ad-hoc in nature.
Rules such as resolution, propagating pure literals, and unit clauses make sense to employ, but it can be unclear when other heuristics are needed.
Choosing an order for decision variables is a much studied and unsolved problem.
In this paper we propose a SAT procedure with dispenses with all of this as unecessary baggage, and simply treats SAT solving as simple, mechanical multinomial normalization.</p></blockquote></div></p><h3>1<tt>&nbsp;</tt><a name="(part._.Introduction)"></a>Introduction</h3><p>The boolean satifiability problem can be phrased as checking whether a boolean-valued function on n-variables is in fact the constant 0 function.
However, the language that we use when solving SAT problems is incongruous with this interpretation, since a given boolean function may be expressible in multiple ways in terms of logical and (&#8743;) and logical or (&#8744;).
We see this in the existence of the conjunctive normal form and disjunctive normal forms.
But if we were to instead use the algebra of &#8743; and xor (&#8853;), then we would have a one to one relation between boolean functions and expressions.
This leads to a simple and elegant algorithm to check whether a quantifier free formula on boolean variables is satisfiable.</p><p>To get an idea of why this may be helpful consider the following workflow.
Start with a formula with operations &#172;, &#8743;, &#8744;, &#8658;, &#8853;, and &#8660;, such as (&#8658; (x&#8320; &#8743; x&#8321;) (x&#8320; &#8743; x&#8321;)), where x&#8320; and x&#8321; are boolean variables.
Transform the formula into one with only &#8743; and &#8853;.
Then simplify the resultant multinomial purely via equational laws of the xor algebra.
If the final formula is anything but 0, the constant 0 function, then the original formula is satisfiable.</p><h3>2<tt>&nbsp;</tt><a name="(part._.Motivation_and_.Background)"></a>Motivation and Background</h3><p>To write the equational laws, I will write &#8853; as + and &#8743; as *, and I will sometimes leave multiplication implicit.
We have commutativity and associativity &ndash; <span class="texMathInline">A+B=B+A</span>, <span class="texMathInline">AB=BA</span>, <span class="texMathInline">(A+B)+C=A+(B+C)</span>, and <span class="texMathInline">(AB)C=A(BC)</span>.
We have top and bottom elements 0 and 1, <span class="texMathInline">A*0=0</span>, <span class="texMathInline">A*1=A</span>, and <span class="texMathInline">AA=A</span>.
Multiplication distributes over addition &ndash; <span class="texMathInline">A(B+C)=AB+AC</span> and <span class="texMathInline">(A+B)C=AC+BC</span>.
But we had all of this in the &#8743;/&#8744; calculus.
What is new is additive identity since <span class="texMathInline">A+0=A</span> and additive inverses since <span class="texMathInline">A+A=0</span>.
In other words, we are working over a field with two elements.</p><p>What does this buy us? Well first of all it justifies our use of &#8853; as + and &#8743; as *.
But more importantly it immediately points toward an algorithm for SAT solving. Namely, convert your propositional logic to &#8853;/&#8743; form, and multiply. If the final result is 0, your formula is UNSAT. Anything else is satisfiable, and a result of 1 entails validity.</p><p>To transform the formula into xor form, we can derive the following equivalences.</p><p>&#172; A &#8660; 1+A</p><p>A&#8744; B &#8660; A+B+AB</p><p>(A &#8658; B) &#8660; (&#172;A)&#8744;B &#8660; &#172; A+B+(&#172; A)B
&#8660; (1+A)+B+(1+A)B
&#8660; 1+A+B+B+AB &#8660; 1+A+AB</p><p>(A &#8660; B) &#8660; &#172; (A+B) &#8660; 1+A+B</p><p>In the Racket programming language:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">compile-to-xor</span><span class="hspace">&nbsp;</span><span class="RktSym">formula</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">symbol?</span><span class="hspace">&nbsp;</span><span class="RktSym">formula</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-mset</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">symbol-&gt;string</span><span class="hspace">&nbsp;</span><span class="RktSym">formula</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">mset-one</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-mset</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">(</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktVal">. </span><span class="RktVal">1</span><span class="RktVal">)</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eq?</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">length</span><span class="hspace">&nbsp;</span><span class="RktSym">formula</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktSym">mset-one</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">compile-to-xor</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cadr</span><span class="hspace">&nbsp;</span><span class="RktSym">formula</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">compile-to-xor</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cadr</span><span class="hspace">&nbsp;</span><span class="RktSym">formula</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">compile-to-xor</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">caddr</span><span class="hspace">&nbsp;</span><span class="RktSym">formula</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">car</span><span class="hspace">&nbsp;</span><span class="RktSym">formula</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">&#172;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktSym">mset-one</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">&#8743;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mult</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">&#8744;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mult</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">&#8658;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktSym">mset-one</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mult</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">&#8853;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">&#8660;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktSym">mset-one</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><h3>3<tt>&nbsp;</tt><a name="(part._.Overview_of_.Proposed_.Approach)"></a>Overview of Proposed Approach</h3><p>Recall the example x&#8320; &#8743; x&#8321; &#8658; x&#8320; &#8743; x&#8321;.
After translating to xor by recursively applying the rule for implication above, we get 1 + x&#8320; * x&#8321; + (x&#8320; * x&#8321;)*(x&#8320; * x&#8321;).
Then:</p><p>1 + x&#8320; * x&#8321; + (x&#8320; * x&#8321;)*(x&#8320; * x&#8321;)</p><p>1 + x&#8320; * x&#8321; + x&#8320; * x&#8321; by <span class="texMathInline">AA=A</span></p><p>1 + 0 by <span class="texMathInline">A+A=0</span></p><p>0 by <span class="texMathInline">A+0=A</span></p><p><div class="SIntrapara">Here is the output of our corresponding compile-to-xor function:
</div><div class="SIntrapara"><p><div class="SIntrapara">Examples:</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">require</span><span class="hspace">&nbsp;</span><span class="RktVal">"sat-solver.rkt"</span><span class="hspace">&nbsp;</span><span class="RktVal">"multinomial-reduction-utils.rkt"</span><span class="RktPn">)</span></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">compile-to-xor</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">&#8658;</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktVal">&#8743;</span><span class="hspace">&nbsp;</span><span class="RktVal">v0</span><span class="hspace">&nbsp;</span><span class="RktVal">v1</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktVal">&#8743;</span><span class="hspace">&nbsp;</span><span class="RktVal">v0</span><span class="hspace">&nbsp;</span><span class="RktVal">v1</span><span class="RktVal">)</span><span class="RktVal">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">(multiset (&#8613; (multiset)))</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">view-multinomial</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">compile-to-xor</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">&#8658;</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktVal">&#8743;</span><span class="hspace">&nbsp;</span><span class="RktVal">v0</span><span class="hspace">&nbsp;</span><span class="RktVal">v1</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktVal">&#8743;</span><span class="hspace">&nbsp;</span><span class="RktVal">v0</span><span class="hspace">&nbsp;</span><span class="RktVal">v1</span><span class="RktVal">)</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">"1"</span></p></td></tr></table></blockquote></div></p></div></p><p>Note that compile-to-xor does not output 1, but rather a nested multiset.
We use an internal representation of multinomials that more directly reflects their equivalences due to their equational laws.
(Explaining the multiset representation is a bit involved though rewarding &ndash; it will not fit in page count. Please view https://github.com/scottviteri/XORSatSolver/multinomial-reduction.html if interested. Even better, it is meant to be viewed after pulling locally and running "scribble &ndash;html multinomial-reduction.rkt", because then you will also get the formatting.)</p><p>We have not only shown that the original formula is satisfiable, but also that it is the constant 1 function, or valid!</p><h3>4<tt>&nbsp;</tt><a name="(part._.Evaluation_.Methodology)"></a>Evaluation Methodology</h3><p>I evaluated the procedure on a combination of hand-crafted and automatically generated formulas.
The automatically generated formulas are created by picking a probability of growing a formula leaf, and also picking a rate at which that probability decays.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">generate-formula</span><span class="hspace">&nbsp;</span><span class="RktSym">prob-expansion</span><span class="hspace">&nbsp;</span><span class="RktSym">decay</span><span class="hspace">&nbsp;</span><span class="RktSym">num-vars</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">generate-random-tree</span><span class="hspace">&nbsp;</span><span class="RktSym">prob-of-expansion</span><span class="hspace">&nbsp;</span><span class="RktSym">decay</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sample-list</span><span class="hspace">&nbsp;</span><span class="RktSym">lst</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">list-ref</span><span class="hspace">&nbsp;</span><span class="RktSym">lst</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">random</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">length</span><span class="hspace">&nbsp;</span><span class="RktSym">lst</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">generate-random-tree-aux</span><span class="hspace">&nbsp;</span><span class="RktSym">prob-of-expansion</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&gt;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">random</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">prob-of-expansion</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">bin-op</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sample-list</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">&#8743;</span><span class="hspace">&nbsp;</span><span class="RktVal">&#8744;</span><span class="hspace">&nbsp;</span><span class="RktVal">&#8658;</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktSym">bin-op</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">generate-random-tree-aux</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktSym">decay</span><span class="hspace">&nbsp;</span><span class="RktSym">prob-of-expansion</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">generate-random-tree-aux</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktSym">decay</span><span class="hspace">&nbsp;</span><span class="RktSym">prob-of-expansion</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">generate-random-tree-aux</span><span class="hspace">&nbsp;</span><span class="RktSym">prob-of-expansion</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">generate-formula-aux</span><span class="hspace">&nbsp;</span><span class="RktSym">formula-tree</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">leaf?</span><span class="hspace">&nbsp;</span><span class="RktSym">formula-tree</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">equal?</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">random</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">string-&gt;symbol</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">string-append</span><span class="hspace">&nbsp;</span><span class="RktVal">"v"</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">number-&gt;string</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">random</span><span class="hspace">&nbsp;</span><span class="RktSym">num-vars</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">&#172;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">string-&gt;symbol</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">string-append</span><span class="hspace">&nbsp;</span><span class="RktVal">"v"</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">number-&gt;string</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">random</span><span class="hspace">&nbsp;</span><span class="RktSym">num-vars</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">car</span><span class="hspace">&nbsp;</span><span class="RktSym">formula-tree</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">generate-formula-aux</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cadr</span><span class="hspace">&nbsp;</span><span class="RktSym">formula-tree</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">generate-formula-aux</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">caddr</span><span class="hspace">&nbsp;</span><span class="RktSym">formula-tree</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">formula-tree</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">generate-random-tree</span><span class="hspace">&nbsp;</span><span class="RktSym">prob-expansion</span><span class="hspace">&nbsp;</span><span class="RktSym">decay</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">generate-formula-aux</span><span class="hspace">&nbsp;</span><span class="RktSym">formula-tree</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><h3>5<tt>&nbsp;</tt><a name="(part._.Results)"></a>Results</h3><h4>5.1<tt>&nbsp;</tt><a name="(part._.Manually_.Generated)"></a>Manually Generated</h4><p>&gt; (view-multinomial (compile-to-xor &rsquo;(&#8658; (&#8743; v0 v1) (&#8743; v0 v1))))</p><p>"1"</p><p>&gt; (view-multinomial (compile-to-xor &rsquo;(&#8658; (&#8743; v0 v1) (&#172; (&#8743; v0 v1)))))</p><p>"1 + v0*v1"</p><p>&gt; (view-multinomial (compile-to-xor &rsquo;(&#8743; (&#8743; v0 v1) (&#172; (&#8743; v0 v1)))))</p><p>"0"</p><p>&gt; (view-multinomial (compile-to-xor &rsquo;(&#8743; v100 v100)))</p><p>"v100"</p><p>&gt; (view-multinomial (compile-to-xor &rsquo;(&#8658; v100 v100)))</p><p>"1"</p><p>&gt; (view-multinomial (compile-to-xor &rsquo;(&#8660; v1 v2)))</p><p>"1 + v1 + v2"</p><h4>5.2<tt>&nbsp;</tt><a name="(part._.Algorithmically_.Generated)"></a>Algorithmically Generated</h4><p><img src="formula-tree-size-v-time.png" alt="" width="400" height="400"/>
<img src="num-distinct-variables-v-time.png" alt="" width="400" height="400"/></p><p>This SAT solver is in the grand scheme of things quite slow.
That said, I have done zero optimizations, and it is very possible that I am converting from the general multinomial case to the boolean multinomial case in a suboptimal way.
I also have not yet experimented with term sharing techniques on the nested multinomial representation.
There may also be optimizations that I can make because we are only looking for satisfiability, as opposed to knowing exactly which boolean function a boolean multinomial is equivalent to, in general.
For all I know, there are moves that we can make that are analogous to gradient descent.</p><h3>6<tt>&nbsp;</tt><a name="(part._.Conclusion)"></a>Conclusion</h3><p>What is the point of a new approach to SAT solving? Isn&rsquo;t the question more or less solved, and further approaches are relegated to bit twiddling? Am I really expecting to beat out the mature state-of-the-art solvers?</p><p>No, well maybe, but that is also not really the point.
This project has helped me understand what SAT solving IS, not what it happens to be.
Yes, this may be or lead to the fewest LOC of any existing solver. This is closer to the point, but still not exactly it.</p><p>As far as I can tell this is open field research.
There is no pre-existing work, and it is difficult for me to predict the discoveries that I will make in advance.
In other words, it is great fun.</p><h3>7<tt>&nbsp;</tt><a name="(part._.Acknowledgements)"></a>Acknowledgements</h3><p>Norman Wildberger is originally responsible for both the ideas of SAT solving with xor&rsquo;s, and of representing polynomials as multisets.
My contribution is implementation of both, as well as discovery and implementation of the representation&rsquo;s extension to the multinomial case.</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cmain~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cmain~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;main&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td></td></tr></table></blockquote></div></p></div></div><div id="contextindicator">&nbsp;</div></body></html>