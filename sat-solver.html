<!DOCTYPE html>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>XOR Sat Solving</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript">
(function() {
  document.write('<link rel="stylesheet" href="katex/katex.min.css" />');
})();(function() {document.write('<scr' + 'ipt type="text/javascript" src="katex/katex.min.js"></scr' + 'ipt>');})();(function(f) {
  // A "simple" onLoad function
  if (window.document.readyState == "complete") {
    f();
  } else if (window.document.addEventListener) {
    window.document.addEventListener("DOMContentLoaded", f, false);
  } else if (window.attachEvent) {
    window.attachEvent("onreadystatechange", function() {
      if (window.document.readyState == "complete") {
        f();
      }
    });
  } else {
    var oldLoad = window.onload;
    if (typeof(oldLoad) == "function") {
      window.onload = function() {
        try {
          oldLoad();
        } finally {
          f();
        }
      };
    } else {
      window.onload = f;
    }
  }
})(function() {
  // This is an ugly way to change the doctype, in case the scribble document
  // did not use (with-html5).
  if (!(document.doctype && document.doctype.publicId == '')) {
    if (console && console.log) {
      console.log("Re-wrote the document to use the HTML5 doctype.\n"
                  + "  Consider using the following declaration:\n"
                  + "      @title[#:style (with-html5 manual-doc-style)]{â€¦}");
    }
    var wholeDoc = '<!doctype HTML>\n' + document.documentElement.outerHTML;
    document.open();
    document.clear();
    document.write(wholeDoc);
  }
  var inlineElements = document.getElementsByClassName("texMathInline");
  for (var i = 0; i < inlineElements.length; i++) {
    var e = inlineElements[i];
    katex.render(e.textContent, e, { displayMode:false, throwOnError:false });
  }
  var displayElements = document.getElementsByClassName("texMathDisplay");
  for (var i = 0; i < displayElements.length; i++) {
    var e = displayElements[i];
    katex.render(e.textContent, e, { displayMode:true, throwOnError:false });
  }
});
</script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;">&bull;</td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">XOR Sat Solving</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.X.O.R_.Sat_.Solving%29" class="tocsubseclink" data-pltdoc="x">XOR Sat Solving</a></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cmain~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;main&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cimports~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;imports&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3csat-solve~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;sat-solve&gt;</a></span></td></tr><tr><td><span class="Smaller"><a href="#%28elem._%28chunk._~3cprovide~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;provide&gt;</a></span></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">7.8</span></div><h2><a name="(part._.X.O.R_.Sat_.Solving)"></a>XOR Sat Solving</h2><p><div class="SIntrapara"><a name="(elem._(chunk._~3cmain~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cmain~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;main&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><a href="#%28elem._%28chunk._~3cimports~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;imports&gt;</a><span class="hspace">&nbsp;</span><a href="#%28elem._%28chunk._~3csat-solve~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;sat-solve&gt;</a><span class="hspace">&nbsp;</span><a href="#%28elem._%28chunk._~3cprovide~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;provide&gt;</a></p></blockquote></div></p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cimports~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cimports~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;imports&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">require</span><span class="hspace">&nbsp;</span><span class="RktVal">"multinomial-reduction-utils.rkt"</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">require</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">only-in</span><span class="hspace">&nbsp;</span><span class="RktVal">"boolean-multinomial-reduction.rkt"</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">add</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">mult</span></span></span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">require</span><span class="hspace">&nbsp;</span><span class="RktSym">racket/match</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>The boolean satifiability problem can be phrased as checking whether a boolean-valued function on n-variables is in fact the constant 0 function.
However, the language that we use when solving SAT problems is incongruous with this interpretation, since a given boolean function may be expressible in multiple ways in terms of logical and (&#8743;) and logical or (&#8744;).
We see this in the existence of the conjunctive normal form and disjunctive normal forms.
But if we were to instead use the algebra of logical and and xor, then we would have a one to one relation between boolean functions and expressions.
This leads to a simple and elegant algorithm to check whether a quantifier free formula on boolean variables is satisfiable.</p><p>To get an idea of why this may be helpful consider the following workflow.
Start with a formula with operations &#172;, &#8743;, &#8744;, &#8658;, &#8853;(xor), and &#8660;, such as <span class="texMathInline">(\Rightarrow (x_0 \land x_1) (x_0 \land x_1))</span>, where <span class="texMathInline">x_0</span> and <span class="texMathInline">x_1</span> are boolean variables.
Transform the formula into one with only &#8743; and &#8853;.
Then simplify the resultant multinomial purely via equational laws of the xor algebra.
If the final formula is anything but 0, the constant 0 function, then the original formula is satisfiable.</p><p>To write the equational laws, I will write &#8853; as + and &#8743; as *, and I will sometimes leave multiplication implicit.
We have commutativity and associativity &ndash; <span class="texMathInline">A+B=B+A</span>, <span class="texMathInline">AB=BA</span>, <span class="texMathInline">(A+B)+C=A+(B+C)</span>, and <span class="texMathInline">(AB)C=A(BC)</span>.
We have top and bottom elements 0 and 1, <span class="texMathInline">A*0=0</span>, <span class="texMathInline">A*1=A</span>, and <span class="texMathInline">AA=A</span>.
Multiplication distributes over addition &ndash; <span class="texMathInline">A(B+C)=AB+AC</span> and <span class="texMathInline">(A+B)C=AC+BC</span>.
But we had all of this in the &#8743;/&#8744; calculus.
What is new is additive identity since <span class="texMathInline">A+0=A</span> and additive inverses since <span class="texMathInline">A+A=0</span>.
In other words, we are working over a field with two elements.</p><p>What does this buy us? Well first of all it justifies our use of &#8853; as + and &#8743; as *.
But more importantly it immediately points toward an algorithm for SAT solving. Namely, convert your propositional logic to &#8853;/&#8743; form, and multiply. If the final result is 0, your formula is UNSAT. Anything else is satisfiable, and a result of 1 entails validity.</p><p>To transform the formula into xor form, we can derive the following equivalences.
<span class="texMathDisplay">\lnot A \Leftrightarrow 1+A</span>
<span class="texMathDisplay">A\lor B \Leftrightarrow A+B+AB</span>
<span class="texMathDisplay">(A\Rightarrow B) \Leftrightarrow \lnot A\lor B
                 \Leftrightarrow \lnot A+B+(\lnot A)B</span>
<span class="texMathDisplay">\Leftrightarrow (1+A)+B+(1+A)B</span>
<span class="texMathDisplay">\Leftrightarrow 1+A+B+B+AB \Leftrightarrow 1+A+AB</span>
<span class="texMathDisplay">(A \Leftrightarrow B) \Leftrightarrow \lnot (A+B) \Leftrightarrow 1+A+B</span></p><p><div class="SIntrapara"><a name="(elem._(chunk._~3csat-solve~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3csat-solve~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;sat-solve&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">compile-to-xor</span><span class="hspace">&nbsp;</span><span class="RktSym">formula</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">symbol?</span><span class="hspace">&nbsp;</span><span class="RktSym">formula</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">make-mset</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">symbol-&gt;string</span><span class="hspace">&nbsp;</span><span class="RktSym">formula</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">mset-one</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">make-mset</span></span></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">(</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktVal">. </span><span class="RktVal">1</span><span class="RktVal">)</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eq?</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">length</span><span class="hspace">&nbsp;</span><span class="RktSym">formula</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">add</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">mset-one</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">compile-to-xor</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cadr</span><span class="hspace">&nbsp;</span><span class="RktSym">formula</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">compile-to-xor</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cadr</span><span class="hspace">&nbsp;</span><span class="RktSym">formula</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">compile-to-xor</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">caddr</span><span class="hspace">&nbsp;</span><span class="RktSym">formula</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">match</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">car</span><span class="hspace">&nbsp;</span><span class="RktSym">formula</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">&#172;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">add</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">mset-one</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">&#8743;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">mult</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">&#8744;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">add</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">mult</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">&#8658;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">add</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">mset-one</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">mult</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">&#8853;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">add</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">&#8660;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">add</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">mset-one</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>Recall the example <span class="texMathInline">x_0 \land x_1 \Rightarrow x_0 \land x_1</span>.
After translating to xor by recursively applying the rule for implication above, we get <span class="texMathInline">1 + x_0 * x_1 + (x_0 * x_1)*(x_0 * x_1)</span>.
Then:</p><p><span class="texMathInline">1 + x_0 * x_1 + (x_0 * x_1)*(x_0 * x_1)</span></p><p><span class="texMathInline">1 + x_0 * x_1 + x_0 * x_1</span> by <span class="texMathInline">AA=A</span></p><p><span class="texMathInline">1 + 0</span> by <span class="texMathInline">A+A=0</span></p><p><span class="texMathInline">1</span> by <span class="texMathInline">A+0=A</span></p><p><div class="SIntrapara">Here is the output of our corresponding compile-to-xor function:
</div><div class="SIntrapara"><p><div class="SIntrapara">Examples:</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">require</span><span class="hspace">&nbsp;</span><span class="RktVal">"sat-solver.rkt"</span><span class="hspace">&nbsp;</span><span class="RktVal">"multinomial-reduction-utils.rkt"</span><span class="RktPn">)</span></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">compile-to-xor</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">&#8658;</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktVal">&#8743;</span><span class="hspace">&nbsp;</span><span class="RktVal">v0</span><span class="hspace">&nbsp;</span><span class="RktVal">v1</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktVal">&#8743;</span><span class="hspace">&nbsp;</span><span class="RktVal">v0</span><span class="hspace">&nbsp;</span><span class="RktVal">v1</span><span class="RktVal">)</span><span class="RktVal">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">(multiset (&#8613; (multiset)))</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">view-multinomial</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">compile-to-xor</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">&#8658;</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktVal">&#8743;</span><span class="hspace">&nbsp;</span><span class="RktVal">v0</span><span class="hspace">&nbsp;</span><span class="RktVal">v1</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktVal">&#8743;</span><span class="hspace">&nbsp;</span><span class="RktVal">v0</span><span class="hspace">&nbsp;</span><span class="RktVal">v1</span><span class="RktVal">)</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">"1"</span></p></td></tr></table></blockquote></div></p></div></p><p>Note that compile-to-xor does not output 1, but rather a nested multiset.
We use an internal representation of multinomials that more directly reflects their equivalences due to their equational laws. To understand this, please read "multinomial-reduction.rkt", or run "scribble &ndash;html multinomial-reduction.rkt" and read the html output.</p><p>We have not only shown that the original formula is satisfiable, but also that it is the constant 1 function, or valid! (Check out "bool-test.rkt" for more examples.) What&rsquo;s more we have done it with very little code in a conceptually clear way. Next I hope to explore the relationship between SAT and the derivatives of their multinomial representations.</p><p><div class="SIntrapara"><a name="(elem._(chunk._~3cprovide~3e~3a1))"></a><span style="font-weight: bold"><span style="font-style: italic"><a href="#%28elem._%28chunk._~3cprovide~3e~3a1%29%29" class="plainlink" data-pltdoc="x">&lt;provide&gt;</a></span> ::=</span></div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">provide</span><span class="hspace">&nbsp;</span><span class="RktSym">compile-to-xor</span><span class="RktPn">)</span></p></blockquote></div></p></div></div><div id="contextindicator">&nbsp;</div></body></html>
